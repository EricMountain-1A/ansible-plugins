#!/usr/bin/env python

# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
# (c) 2013, Serge van Ginderachter <serge@vanginderachter.be>
#
# This file was based on bin/ansible
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

########################################################

import sys
import os
import stat
import errno
import yaml

import ansible.constants as C
from ansible import utils
from ansible import errors
from ansible import inventory

########################################################


def _load_vars(basepath, results, vault_password=None):
    """
    Load variables from any potential yaml filename combinations of basepath,
    returning result.
    """

    paths_to_check = [ "".join([basepath, ext]) 
                       for ext in C.YAML_FILENAME_EXTENSIONS ]

    found_paths = []

    for path in paths_to_check:
        found, results = _load_vars_from_path(path, results, vault_password=vault_password)
        if found:
            found_paths.append(path)


    # disallow the potentially confusing situation that there are multiple
    # variable files for the same name. For example if both group_vars/all.yml
    # and group_vars/all.yaml
    if len(found_paths) > 1:
        raise errors.AnsibleError("Multiple variable files found. "
            "There should only be one. %s" % ( found_paths, ))

    return results

def _load_vars_from_path(path, results, vault_password=None):
    """
    Robustly access the file at path and load variables, carefully reporting
    errors in a friendly/informative way.

    Return the tuple (found, new_results, )
    """

    try:
        # in the case of a symbolic link, we want the stat of the link itself,
        # not its target
        pathstat = os.lstat(path)
    except os.error, err:
        # most common case is that nothing exists at that path.
        if err.errno == errno.ENOENT:
            return False, results
        # otherwise this is a condition we should report to the user
        raise errors.AnsibleError(
            "%s is not accessible: %s." 
            " Please check its permissions." % ( path, err.strerror))

    # symbolic link
    if stat.S_ISLNK(pathstat.st_mode):
        try:
            target = os.path.realpath(path)
        except os.error, err2:
            raise errors.AnsibleError("The symbolic link at %s "
                "is not readable: %s.  Please check its permissions."
                % (path, err2.strerror, ))
        # follow symbolic link chains by recursing, so we repeat the same
        # permissions checks above and provide useful errors.
        return _load_vars_from_path(target, results)

    # directory
    if stat.S_ISDIR(pathstat.st_mode):

        # support organizing variables across multiple files in a directory
        return True, _load_vars_from_folder(path, results)

    # regular file
    elif stat.S_ISREG(pathstat.st_mode):
        data = utils.parse_yaml_from_file(path, vault_password=vault_password)
        if type(data) != dict:
            raise errors.AnsibleError(
                "%s must be stored as a dictionary/hash" % path)

        # combine vars overrides by default but can be configured to do a
        # hash merge in settings
        results = utils.combine_vars(results, data)
        return True, results

    # something else? could be a fifo, socket, device, etc.
    else:
        raise errors.AnsibleError("Expected a variable file or directory "
            "but found a non-file object at path %s" % (path, ))

def _load_vars_from_folder(folder_path, results):
    """
    Load all variables within a folder recursively.
    """

    # this function and _load_vars_from_path are mutually recursive

    try:
        names = os.listdir(folder_path)
    except os.error, err:
        raise errors.AnsibleError(
            "This folder cannot be listed: %s: %s." 
             % ( folder_path, err.strerror))
        
    # evaluate files in a stable order rather than whatever order the
    # filesystem lists them.
    names.sort() 

    paths = [os.path.join(folder_path, name) for name in names]
    for path in paths:
        _found, results = _load_vars_from_path(path, results)
    return results

########################################################


def flatten(terms):
    ret = []
    for term in terms:
        if isinstance(term, list):
            ret.extend(term)
        else:
            ret.append(term)
    return ret


########################################################


class Cli(object):

    # ----------------------------------------------

    def __init__(self):
        pass

    # ----------------------------------------------

    def parse(self):

        parser = utils.SortedOptParser(
            usage='%prog <host-pattern> [options]'
        )
        parser.add_option('-l', '--limit', default=C.DEFAULT_SUBSET, dest='subset',
            help='further limit selected hosts to an additional pattern')
        parser.add_option('-i', '--inventory-file', dest='inventory',
            help="specify inventory host file (default=%s)" % C.DEFAULT_HOST_LIST,
            default=C.DEFAULT_HOST_LIST)
        parser.add_option('-y', '--yaml', dest='yaml', action='store_true',
            help="dump out variables in yaml format")
        parser.add_option('-j', '--json', '--list', dest='json', action='store_true',
            help="dump out variables in json format (default)")
        parser.add_option('--host', dest='host', action='store_true',
            help="n/a for backwards compatibility as ansible inventory script")

        options, args = parser.parse_args()
        if len(args) == 0:
            args = ['all']
        if len(args) > 1:
            parser.print_help()
            sys.exit(1)
        return (options, args)

    # ----------------------------------------------

    def run(self, options, args):

        if options.host:
            return {}

        pattern = args[0]

        I = inventory.Inventory(options.inventory)
        if options.subset:
            I.subset(options.subset)
        hosts = I.list_hosts(pattern)
        if len(hosts) == 0:
            print >>sys.stderr, "No hosts matched"
            sys.exit(1)

        results = {'_meta': {'hostvars': {}}}

        # get inventory groups and hosts into result set
        groups = I.get_groups()
        for group in groups:
            host_list = [h.name for h in group.hosts ]
            child_groups_list = [g.name for g in group.child_groups ]
            results[group.name] = dict(children=child_groups_list, hosts=host_list)

        # get hostvars from inventory scripts through --host parameter
        if I.parser is not None:
            for host in hosts:
                results['_meta']['hostvars'][host] = I.parser.get_host_variables(I.get_host(host))

        # get hostvars from vars_plugins? No can do,
        # vars_plugins only load vars per host, and we want them per original
        # group, so this is a quick hack based on the plugin
        basedir = I.basedir()
        for host in hosts:
            base_path = os.path.join(basedir, "host_vars/%s" % host)
            loadedvars = _load_vars(base_path, {})
            if loadedvars != {}:
                results['_meta']['hostvars'][host] = loadedvars
        for group in groups:
            base_path = os.path.join(basedir, "group_vars/%s" % group.name)
            loadedvars = _load_vars(base_path, {})
            if loadedvars != {}:
                results[group.name]['vars'] = loadedvars


        return results

########################################################

if __name__ == '__main__':
    cli = Cli()
    (options, args) = cli.parse()
    try:
        results = cli.run(options, args)
    except errors.AnsibleError, e:
        # Generic handler for ansible specific errors
        print "ERROR: %s" % str(e)
        sys.exit(1)
    if options.yaml:
        print yaml.safe_dump(results)
    else:
        print utils.jsonify(results, format=True)

